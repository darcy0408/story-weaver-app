input {
  tcp {
    port => 5044
    codec => json
  }
  http {
    port => 8080
    codec => json
  }
}

filter {
  if [kubernetes] {
    mutate {
      add_field => { "container_name" => "%{[kubernetes][container_name]}" }
      add_field => { "namespace" => "%{[kubernetes][namespace_name]}" }
      add_field => { "pod" => "%{[kubernetes][pod_name]}" }
    }
  }

  # Parse Railway logs
  if [message] =~ /railway/ {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:level} %{GREEDYDATA:message}" }
    }
  }

  # Parse Flask logs
  if [message] =~ /flask/ {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{WORD:level} %{DATA:module}: %{GREEDYDATA:message}" }
    }
  }

  # Extract user IDs and story metrics
  if [message] =~ /story.*generated/ {
    grok {
      match => { "message" => "Story generated for user %{WORD:user_id} in %{NUMBER:duration:float} seconds" }
    }
  }

  # Add geo information for IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "story-weaver-%{+YYYY.MM.dd}"
  }

  # Also send to Loki for correlation
  http {
    url => "http://loki:3100/loki/api/v1/push"
    format => "json_batch"
    http_method => "post"
    mapping => {
      "streams" => [
        {
          "stream" => {
            "job" => "logstash"
            "level" => "%{level}"
          }
          "values" => [
            [
              "%{[@timestamp]}",
              "%{message}"
            ]
          ]
        }
      ]
    }
  }
}